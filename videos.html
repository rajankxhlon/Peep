<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Peeps Reels</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #000;
            display: flex;
            flex-direction: column; /* Changed to column to stack nav and reels */
            justify-content: flex-start; /* Align items to the start */
            align-items: center;
            min-height: 100vh;
            overflow: hidden; /* Hide scrollbars, we'll manage scrolling with JS */
            font-family: Arial, sans-serif;
            color: white;
        }

        .reel-navigation {
            position: fixed;
            top: 0;
            width: 100%;
            display: flex;
            justify-content: center;
            /* CRUCIAL CHANGE: Add a background color to intercept clicks */
            background-color: rgba(0, 0, 0, 0.5); /* Semi-transparent black background */
            padding: 10px 0;
            z-index: 20; /* Ensure it's above reels-container and overlay */
            border-bottom: none; /* Changed: Removed border */
            box-sizing: border-box; /* Include padding in width */
            pointer-events: auto; /* Ensure the navigation div itself receives pointer events */
        }

        .nav-btn {
            background: none;
            border: none;
            color: rgba(255, 255, 255, 0.6);
            font-size: 16px;
            padding: 10px 20px;
            cursor: pointer;
            transition: color 0.3s ease, border-bottom 0.3s ease;
            font-weight: bold;
            pointer-events: auto; /* Ensure buttons inside also receive pointer events */
        }

        .nav-btn.active {
            color: white;
            border-bottom: 2px solid white;
        }

        .nav-btn:hover:not(.active) {
            color: rgba(255, 255, 255, 0.8);
        }

        .reels-container {
            width: 100%;
            height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            justify-content: flex-start;
            position: relative;
            scroll-snap-type: y mandatory;
            overflow-y: scroll;
            -webkit-overflow-scrolling: touch;
            scroll-behavior: smooth;
            padding-top: 50px; /* Space for the navigation bar */
            box-sizing: border-box; /* Include padding in height */
        }

        .reel-item {
            flex-shrink: 0;
            flex-grow: 1;
            width: 100%;
            min-height: 100vh;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #000;
            scroll-snap-align: start;
        }

        .reel-video {
            width: 100%;
            height: 100%;
            object-fit: contain;
            background-color: black;
        }

        .reel-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 15px;
            box-sizing: border-box;
            background: linear-gradient(to top, rgba(0,0,0,0.6) 0%, transparent 30%, transparent 70%, rgba(0,0,0,0.4) 100%);
        }

        .reel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            padding-bottom: 10px;
            padding-top: 10px; /* Added to account for the nav bar */
            box-sizing: border-box;
            position: relative; /* ADDED: To allow z-index to work */
            z-index: 25; /* ADDED: Higher than .reel-navigation */
        }

        .reel-header .back-btn {
            background: none;
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
            padding: 5px;
        }

        .reel-header .back-btn:hover {
            opacity: 0.8;
        }

        .reel-sidebar {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            position: absolute;
            right: 15px;
            bottom: 80px;
        }

        .sidebar-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            color: white;
            font-size: 14px;
            cursor: pointer;
            text-decoration: none;
        }

        .sidebar-item i {
            font-size: 24px;
            margin-bottom: 5px;
            transition: color 0.2s ease-in-out;
        }

        .sidebar-item:hover i, .sidebar-item.liked i {
            color: #e0245e;
        }
        .sidebar-item.reposted i {
            color: #17bf63;
        }


        .sidebar-item .profile-pic-reel {
            width: 45px;
            height: 45px;
            border-radius: 50%;
            border: 2px solid white;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #ddd;
            color: #555;
            font-size: 20px;
            font-weight: bold;
            text-transform: uppercase;
            margin-bottom: 10px;
        }

        .sidebar-item .profile-pic-reel img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .spinning-disk {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background-color: #333;
            border: 2px solid white;
            position: relative;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            animation: spin 5s linear infinite;
        }

        .spinning-disk img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 50%;
        }

        .spinning-disk span {
            font-size: 18px;
            color: white;
            font-weight: bold;
        }

        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        .reel-content-details {
            position: absolute;
            left: 15px;
            bottom: 80px;
            width: calc(100% - 150px);
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .reel-username {
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .reel-username .verified-tick {
            width: 16px;
            height: 16px;
            vertical-align: middle;
            margin-left: 0;
            flex-shrink: 0;
        }

        .follow-unfollow-btn {
            background-color: #1da1f2;
            color: white;
            border: none;
            border-radius: 5px;
            padding: 5px 10px;
            font-size: 13px;
            cursor: pointer;
            transition: background-color 0.2s ease-in-out;
            margin-left: 10px;
        }

        .follow-unfollow-btn:hover {
            background-color: #0d8ddb;
        }

        .follow-unfollow-btn.unfollow {
            background-color: #e0245e;
        }

        .follow-unfollow-btn.unfollow:hover {
            background-color: #c71c4c;
        }

        .follow-unfollow-btn:disabled {
            background-color: #555;
            cursor: not-allowed;
        }

        .reel-description {
            font-size: 15px;
            word-wrap: break-word;
            max-height: 80px;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* New position and style for mute/unmute button */
        .mute-unmute-btn {
            position: absolute;
            bottom: 20px; /* Moved lower */
            left: 20px; /* Aligned to the left, below other content */
            background: rgba(0, 0, 0, 0.5);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            z-index: 15; /* Ensure it's above other overlay elements if needed */
            transition: visibility 0.5s, opacity 0.5s ease-in-out; /* Smooth transition for disappearance */
            opacity: 1; /* Initially visible */
        }

        .mute-unmute-btn i {
            font-size: 20px;
            color: white;
            margin: 0;
        }

        .mute-unmute-btn.hidden {
            opacity: 0;
            visibility: hidden;
            pointer-events: none; /* Make it unclickable when hidden */
        }


        @media (max-width: 600px) {
            .reel-overlay {
                padding: 10px;
            }
            .reel-sidebar {
                right: 5px;
                bottom: 70px;
                gap: 15px;
            }
            .sidebar-item i {
                font-size: 20px;
            }
            .sidebar-item .profile-pic-reel {
                width: 40px;
                height: 40px;
            }
            .spinning-disk {
                width: 40px;
                height: 40px;
            }
            .spinning-disk span {
                font-size: 16px;
            }
            .mute-unmute-btn {
                width: 35px;
                height: 35px;
                bottom: 15px;
                left: 15px;
            }
            .mute-unmute-btn i {
                font-size: 18px;
            }
            .reel-content-details {
                left: 10px;
                bottom: 70px;
                width: calc(100% - 100px);
            }
            .reel-username {
                font-size: 14px;
            }
            .reel-description {
                font-size: 14px;
            }
            .reel-navigation {
                padding: 8px 0;
            }
            .nav-btn {
                font-size: 15px;
                padding: 8px 15px;
            }
            .reels-container {
                padding-top: 45px;
            }
            .reel-header {
                padding-top: 5px;
            }
        }
    </style>
</head>
<body>
    <div class="reel-navigation">
        <button class="nav-btn active" id="forYouBtn">For You</button>
        <button class="nav-btn" id="followingBtn">Following</button>
    </div>

    <div class="reels-container" id="reels-container">
        </div>

    <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore-compat.js"></script>

    <script>
        // Your Firebase configuration (same as home.html)
        const firebaseConfig = {
            apiKey: "AIzaSyBh9gNTXJYgcvt4vuiV5U0UqSeFhH8afcA",
            authDomain: "yellowchat-ad31a.firebaseapp.com",
            databaseURL: "https://yellowchat-ad31a-default-rtdb.firebaseio.com",
            projectId: "yellowchat-ad31a",
            storageBucket: "yellowchat-ad31a.firebasestorage.app",
            messagingSenderId: "592543476537",
            appId: "1:592543476537:web:10a2102227c06ac0d756e8",
            measurementId: "G-2BZFXPKCHD"
        };

        // Initialize Firebase
        firebase.initializeApp(firebaseConfig);

        // Firebase services
        const auth = firebase.auth();
        const db = firebase.firestore();

        const reelsContainer = document.getElementById('reels-container');
        const forYouBtn = document.getElementById('forYouBtn');
        const followingBtn = document.getElementById('followingBtn');

        let currentUserId = null;
        let currentUsername = null;
        let following = new Set(); // Store usernames the current user is following
        let isMutedGlobally = true; // Track global mute state
        let currentView = 'forYou'; // Default view

        // Function to create the verified tick SVG element (reused from home.html)
        function createVerifiedTickSvg() {
            const svgString = `<svg class="verified-tick" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" width="256" height="256" viewBox="0 0 256 256" xml:space="preserve">
<g style="stroke: none; stroke-width: 0; stroke-dasharray: none; stroke-linecap: butt; stroke-linejoin: miter; stroke-miterlimit: 10; fill: none; fill-rule: nonzero; opacity: 1;" transform="translate(1.4065934065934016 1.4065934065934016) scale(2.81 2.81)">
	<polygon points="45,6.18 57.06,0 64.41,11.38 77.94,12.06 78.62,25.59 90,32.94 83.82,45 90,57.06 78.62,64.41 77.94,77.94 64.41,78.62 57.06,90 45,83.82 32.94,90 25.59,78.62 12.06,77.94 11.38,64.41 0,57.06 6.18,45 0,32.94 11.38,25.59 12.06,12.06 25.59,11.38 32.94,0 " style="stroke: none; stroke-width: 1; stroke-dasharray: none; stroke-linecap: butt; stroke-linejoin: miter; stroke-miterlimit: 10; fill: rgb(0,150,241); fill-rule: nonzero; opacity: 1;" transform="  matrix(1 0 0 1 0 0) "/>
	<polygon points="40.16,58.47 26.24,45.08 29.7,41.48 40.15,51.52 61.22,31.08 64.7,34.67 " style="stroke: none; stroke-width: 1; stroke-dasharray: none; stroke-linecap: butt; stroke-linejoin: miter; stroke-miterlimit: 10; fill: rgb(255,255,255); fill-rule: nonzero; opacity: 1;" transform="  matrix(1 0 0 1 0 0) "/>
</g>
</svg>`;
            const parser = new DOMParser();
            const svgDoc = parser.parseFromString(svgString, "image/svg+xml");
            return svgDoc.documentElement;
        }

        // Function to fetch current user's following list (reused from home.html)
        async function fetchFollowingList(userId) {
            if (!userId) return;
            try {
                const userDoc = await db.collection('users').doc(userId).get();
                if (userDoc.exists) {
                    const userData = userDoc.data();
                    following = new Set(userData.following || []);
                } else {
                    following = new Set();
                }
            } catch (error) {
                console.error("Error fetching following list:", error);
            }
        }

        // Function to handle follow/unfollow action (reused from home.html, adapted for current context)
        async function toggleFollow(targetUsername, targetUserId, buttonElement) {
            if (!currentUserId || !currentUsername) {
                alert("You must be logged in to follow/unfollow users.");
                window.location.href = 'index.html'; // Redirect to login
                return;
            }

            if (targetUsername === currentUsername) {
                alert("You cannot follow or unfollow yourself.");
                return;
            }

            const userRef = db.collection('users').doc(currentUserId);
            const targetUserRef = db.collection('users').doc(targetUserId);

            try {
                if (following.has(targetUsername)) {
                    // Unfollow
                    await userRef.update({ following: firebase.firestore.FieldValue.arrayRemove(targetUsername) });
                    await targetUserRef.update({ followers: firebase.firestore.FieldValue.arrayRemove(currentUsername) });
                    following.delete(targetUsername);
                    buttonElement.textContent = 'Follow';
                    buttonElement.classList.remove('unfollow');
                } else {
                    // Follow
                    await userRef.update({ following: firebase.firestore.FieldValue.arrayUnion(targetUsername) });
                    await targetUserRef.update({ followers: firebase.firestore.FieldValue.arrayUnion(currentUsername) });
                    following.add(targetUsername);
                    buttonElement.textContent = 'Unfollow';
                    buttonElement.classList.add('unfollow');

                    // Create/Update follow notification
                    try {
                        const existingNotificationQuery = await db.collection('notifications')
                            .where('type', '==', 'follow')
                            .where('fromUserId', '==', currentUserId)
                            .where('toUserId', '==', targetUserId)
                            .limit(1)
                            .get();

                        if (!existingNotificationQuery.empty) {
                            const existingNotificationDoc = existingNotificationQuery.docs[0];
                            await existingNotificationDoc.ref.update({
                                timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                                read: false,
                                actionTaken: false
                            });
                        } else {
                            await db.collection('notifications').add({
                                type: 'follow',
                                fromUsername: currentUsername,
                                fromUserId: currentUserId,
                                toUsername: targetUsername,
                                toUserId: targetUserId,
                                timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                                read: false,
                                actionTaken: false
                            });
                        }
                    } catch (notificationError) {
                        console.error("Error handling follow notification:", notificationError);
                    }
                }
            } catch (error) {
                console.error("Error toggling follow status:", error);
                alert("Failed to update follow status. Please try again.");
            }
        }

        // Object to cache user data to avoid redundant fetches
        const usersCache = {};

        // Function to create a single reel item
        async function createReelItem(tweet, tweetAuthorData) {
            if (!tweet.videoUrl) return null;

            const reelItem = document.createElement('div');
            reelItem.classList.add('reel-item');
            reelItem.dataset.tweetId = tweet.id;

            const video = document.createElement('video');
            video.classList.add('reel-video');
            video.src = tweet.videoUrl;
            video.loop = true;
            video.muted = isMutedGlobally;
            video.playsInline = true;
            video.preload = "metadata";

            const overlay = document.createElement('div');
            overlay.classList.add('reel-overlay');

            // Header (Back button only)
            const reelHeader = document.createElement('div');
            reelHeader.classList.add('reel-header');

            const backButton = document.createElement('button');
            backButton.classList.add('back-btn');
            backButton.innerHTML = '<i class="fas fa-arrow-left"></i>';
            backButton.addEventListener('click', () => window.history.back());
            reelHeader.appendChild(backButton);
            overlay.appendChild(reelHeader); // Append header to overlay

            // Mute/Unmute Button (Moved here)
            const muteUnmuteButton = document.createElement('div');
            muteUnmuteButton.classList.add('mute-unmute-btn');
            const muteUnmuteIcon = document.createElement('i');
            muteUnmuteIcon.classList.add('fas', isMutedGlobally ? 'fa-volume-mute' : 'fa-volume-up');
            muteUnmuteButton.appendChild(muteUnmuteIcon);

            // Add 'hidden' class initially if not muted globally (unlikely on load, but for consistency)
            if (!isMutedGlobally) {
                muteUnmuteButton.classList.add('hidden');
            }

            muteUnmuteButton.addEventListener('click', () => {
                isMutedGlobally = !isMutedGlobally;
                // Update icon
                if (isMutedGlobally) {
                    muteUnmuteIcon.classList.replace('fa-volume-up', 'fa-volume-mute');
                    muteUnmuteButton.classList.remove('hidden'); // Show if re-muting
                } else {
                    muteUnmuteIcon.classList.replace('fa-volume-mute', 'fa-volume-up');
                    muteUnmuteButton.classList.add('hidden'); // Hide if unmuting
                }

                // Apply to all videos that are currently visible/playing or in the DOM
                document.querySelectorAll('.reel-video').forEach(vid => {
                    vid.muted = isMutedGlobally;
                });

                // If a video is currently playing, ensure its state is updated
                if (currentlyPlayingVideo) {
                    currentlyPlayingVideo.muted = isMutedGlobally;
                }
            });
            overlay.appendChild(muteUnmuteButton); // Append directly to overlay, not header


            // Sidebar (Profile, Like, Comment, Repost, More, Spinning Disk)
            const reelSidebar = document.createElement('div');
            reelSidebar.classList.add('reel-sidebar');

            // Profile Picture
            const profilePicItem = document.createElement('a');
            profilePicItem.classList.add('sidebar-item');
            profilePicItem.href = `user_profile.html?username=${encodeURIComponent(tweet.username)}`;
            const profilePicContainer = document.createElement('div');
            profilePicContainer.classList.add('profile-pic-reel');
            if (tweetAuthorData && tweetAuthorData.profilePictureUrl) {
                const profilePicImg = document.createElement('img');
                profilePicImg.src = tweetAuthorData.profilePictureUrl;
                profilePicImg.alt = `${tweet.username}'s profile picture`;
                profilePicContainer.appendChild(profilePicImg);
            } else {
                const firstLetter = document.createElement('span');
                firstLetter.textContent = tweet.username ? tweet.username.charAt(0).toUpperCase() : '?';
                profilePicContainer.appendChild(firstLetter);
            }
            profilePicItem.appendChild(profilePicContainer);
            reelSidebar.appendChild(profilePicItem);


            // Like Button
            const likeItem = document.createElement('div');
            likeItem.classList.add('sidebar-item', 'like-btn');
            likeItem.innerHTML = `<i class="far fa-heart"></i> <span class="like-count">${tweet.likes ? tweet.likes.length : 0}</span>`;
            if (currentUserId && (tweet.likes || []).includes(currentUserId)) {
                likeItem.classList.add('liked');
                likeItem.querySelector('i').classList.replace('far', 'fas');
            }
            likeItem.addEventListener('click', async () => {
                if (!currentUserId) {
                    alert("You must be logged in to like videos.");
                    window.location.href = 'index.html';
                    return;
                }
                const tweetRef = db.collection('tweets').doc(tweet.id);
                const currentLikes = new Set(tweet.likes || []);
                try {
                    if (currentLikes.has(currentUserId)) {
                        await tweetRef.update({ likes: firebase.firestore.FieldValue.arrayRemove(currentUserId) });
                        currentLikes.delete(currentUserId);
                        likeItem.classList.remove('liked');
                        likeItem.querySelector('i').classList.replace('fas', 'far');
                    } else {
                        await tweetRef.update({ likes: firebase.firestore.FieldValue.arrayUnion(currentUserId) });
                        currentLikes.add(currentUserId);
                        likeItem.classList.add('liked');
                        likeItem.querySelector('i').classList.replace('far', 'fas');
                        if (tweet.userId !== currentUserId) {
                            try {
                                await db.collection('notifications').add({
                                    type: 'like',
                                    fromUsername: currentUsername,
                                    fromUserId: currentUserId,
                                    toUsername: tweet.username,
                                    toUserId: tweet.userId,
                                    tweetId: tweet.id,
                                    tweetContent: tweet.content ? tweet.content.substring(0, 50) + (tweet.content.length > 50 ? '...' : '') : 'Video',
                                    timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                                    read: false
                                });
                            } catch (e) { console.error("Error creating like notification:", e); }
                        }
                    }
                    likeItem.querySelector('.like-count').textContent = currentLikes.size;
                    tweet.likes = Array.from(currentLikes);
                } catch (error) { console.error("Error updating like status:", error); }
            });
            reelSidebar.appendChild(likeItem);

            // Comment Button (without reply count)
            const commentItem = document.createElement('a');
            commentItem.classList.add('sidebar-item', 'comment-btn');
            commentItem.href = `reply.html?tweetId=${tweet.id}`;
            commentItem.innerHTML = `<i class="far fa-comment"></i>`; // Removed <span>${tweet.replyCount || 0}</span>
            reelSidebar.appendChild(commentItem);

            // Repost Button
            const repostItem = document.createElement('div');
            repostItem.classList.add('sidebar-item', 'repost-btn');
            repostItem.innerHTML = `<i class="fas fa-retweet"></i> <span class="repost-count">${tweet.reposts ? tweet.reposts.length : 0}</span>`;
            if (currentUserId && (tweet.reposts || []).includes(currentUserId)) {
                repostItem.classList.add('reposted');
            }
            repostItem.addEventListener('click', async () => {
                if (!currentUserId) {
                    alert("You must be logged in to repost videos.");
                    window.location.href = 'index.html';
                    return;
                }
                const tweetRef = db.collection('tweets').doc(tweet.id);
                const currentReposts = new Set(tweet.reposts || []);
                try {
                    if (currentReposts.has(currentUserId)) {
                        await tweetRef.update({ reposts: firebase.firestore.FieldValue.arrayRemove(currentUserId) });
                        currentReposts.delete(currentUserId);
                        repostItem.classList.remove('reposted');
                    } else {
                        await tweetRef.update({ reposts: firebase.firestore.FieldValue.arrayUnion(currentUserId) });
                        currentReposts.add(currentUserId);
                        repostItem.classList.add('reposted');
                        if (tweet.userId !== currentUserId) {
                            try {
                                await db.collection('notifications').add({
                                    type: 'repost',
                                    fromUsername: currentUsername,
                                    fromUserId: currentUserId,
                                    toUsername: tweet.username,
                                    toUserId: tweet.userId,
                                    tweetId: tweet.id,
                                    tweetContent: tweet.content ? tweet.content.substring(0, 50) + (tweet.content.length > 50 ? '...' : '') : 'Video',
                                    timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                                    read: false
                                });
                            } catch (e) { console.error("Error creating repost notification:", e); }
                        }
                    }
                    repostItem.querySelector('.repost-count').textContent = currentReposts.size;
                    tweet.reposts = Array.from(currentReposts);
                } catch (error) { console.error("Error updating repost status:", error); }
            });
            reelSidebar.appendChild(repostItem);


            // More (Three Dots)
            const moreItem = document.createElement('div');
            moreItem.classList.add('sidebar-item');
            moreItem.innerHTML = '<i class="fas fa-ellipsis-h"></i>';
            moreItem.addEventListener('click', () => {
                alert('More options for this video (not yet implemented)');
            });
            reelSidebar.appendChild(moreItem);

            // Spinning Disk (Music Icon or Placeholder with Profile Pic)
            const spinningDisk = document.createElement('div');
            spinningDisk.classList.add('spinning-disk');
            if (tweetAuthorData && tweetAuthorData.profilePictureUrl) {
                const diskImg = document.createElement('img');
                diskImg.src = tweetAuthorData.profilePictureUrl;
                diskImg.alt = `${tweet.username}'s profile picture`;
                spinningDisk.appendChild(diskImg);
            } else {
                const firstLetter = document.createElement('span');
                firstLetter.textContent = tweet.username ? tweet.username.charAt(0).toUpperCase() : '?';
                spinningDisk.appendChild(firstLetter);
            }
            reelSidebar.appendChild(spinningDisk);

            overlay.appendChild(reelSidebar);

            // Content Details (Username, Description, Follow Button)
            const contentDetails = document.createElement('div');
            contentDetails.classList.add('reel-content-details');

            const usernameLine = document.createElement('div');
            usernameLine.classList.add('reel-username');

            const usernameLink = document.createElement('a');
            usernameLink.href = `user_profile.html?username=${encodeURIComponent(tweet.username)}`;
            usernameLink.style.color = 'inherit';
            usernameLink.style.textDecoration = 'none';
            usernameLink.style.fontWeight = 'bold';
            usernameLink.textContent = `@${tweet.username}`;

            usernameLine.appendChild(usernameLink);

            if (tweetAuthorData && tweetAuthorData.isVerified) {
                usernameLine.appendChild(createVerifiedTickSvg());
            }

            // Follow/Unfollow Button
            const followButton = document.createElement('button');
            followButton.classList.add('follow-unfollow-btn');
            followButton.dataset.username = tweet.username;
            followButton.dataset.userId = tweet.userId;

            if (currentUsername && tweet.username === currentUsername) {
                followButton.textContent = 'You';
                followButton.disabled = true;
            } else if (following.has(tweet.username)) {
                followButton.textContent = 'Unfollow';
                followButton.classList.add('unfollow');
            } else {
                followButton.textContent = 'Follow';
            }

            followButton.addEventListener('click', () => {
                toggleFollow(tweet.username, tweet.userId, followButton);
            });
            usernameLine.appendChild(followButton);

            contentDetails.appendChild(usernameLine);

            if (tweet.content) {
                const descriptionP = document.createElement('p');
                descriptionP.classList.add('reel-description');
                descriptionP.textContent = tweet.content;
                contentDetails.appendChild(descriptionP);
            }

            overlay.appendChild(contentDetails);

            reelItem.appendChild(video);
            reelItem.appendChild(overlay);

            return reelItem;
        }

        // --- Intersection Observer for Video Autoplay ---
        const videoObserverOptions = {
            root: null,
            rootMargin: '0px',
            threshold: 0.7
        };

        let currentlyPlayingVideo = null;

        const videoObserver = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                const video = entry.target;
                const muteButton = video.closest('.reel-item').querySelector('.mute-unmute-btn'); // Get the mute button for this video

                if (entry.isIntersecting) {
                    if (currentlyPlayingVideo && currentlyPlayingVideo !== video) {
                        currentlyPlayingVideo.pause();
                        currentlyPlayingVideo.currentTime = 0;
                        // Show mute button for the previously playing video if it was unmuted
                        const prevMuteButton = currentlyPlayingVideo.closest('.reel-item').querySelector('.mute-unmute-btn');
                        if (prevMuteButton) {
                            prevMuteButton.classList.remove('hidden');
                        }
                    }
                    video.muted = isMutedGlobally;
                    video.play().catch(error => {
                        console.warn("Video autoplay prevented:", error);
                    });
                    currentlyPlayingVideo = video;

                    // Update mute button visibility for the new video
                    if (muteButton) {
                        if (isMutedGlobally) {
                            muteButton.classList.remove('hidden'); // Show if muted
                        } else {
                            muteButton.classList.add('hidden'); // Hide if already unmuted
                        }
                    }

                } else {
                    if (video === currentlyPlayingVideo) {
                        video.pause();
                        video.currentTime = 0;
                        currentlyPlayingVideo = null;
                        // Show mute button when video scrolls out of view (if it was unmuted)
                        if (muteButton) {
                            muteButton.classList.remove('hidden');
                        }
                    }
                }
            });
        }, videoObserverOptions);


        // Function to fetch and display videos (reels) based on view
        async function fetchAndDisplayReels(view) {
            // Stop any currently playing video before clearing the container
            if (currentlyPlayingVideo) {
                currentlyPlayingVideo.pause();
                currentlyPlayingVideo.currentTime = 0;
                currentlyPlayingVideo = null;
            }
            reelsContainer.innerHTML = '<p style="text-align: center; color: #66757f; margin: auto; padding-top: 50vh;">Loading videos...</p>';
            try {
                const tweetsSnapshot = await db.collection('tweets').get();
                let videoTweets = [];
                const userPromises = [];

                tweetsSnapshot.forEach(doc => {
                    const tweet = { id: doc.id, ...doc.data() };
                    if (tweet.videoUrl) {
                        // Filter based on the current view
                        if (view === 'forYou') {
                            videoTweets.push(tweet);
                        } else if (view === 'following' && currentUsername && following.has(tweet.username)) {
                            videoTweets.push(tweet);
                        }

                        // Collect user IDs for caching
                        if (!usersCache[tweet.userId]) {
                            userPromises.push(db.collection('users').doc(tweet.userId).get());
                        }
                    }
                });

                if (videoTweets.length === 0) {
                    let message = 'No videos found.';
                    if (view === 'following') {
                        message = 'No videos from users you follow. Follow more people to see their reels here!';
                    } else {
                        message = 'No videos found. Be the first to share a video!';
                    }
                    reelsContainer.innerHTML = `<p style="text-align: center; color: #66757f; margin: auto; padding-top: 50vh;">${message}</p>`;
                    return;
                }

                const userDocs = await Promise.all(userPromises);
                userDocs.forEach(userDoc => {
                    if (userDoc.exists) {
                        usersCache[userDoc.id] = userDoc.data();
                    }
                });

                shuffleArray(videoTweets);

                reelsContainer.innerHTML = '';

                for (const tweet of videoTweets) {
                    const tweetAuthorData = usersCache[tweet.userId] || null;
                    const reelItem = await createReelItem(tweet, tweetAuthorData);
                    if (reelItem) {
                        reelsContainer.appendChild(reelItem);
                        const videoElement = reelItem.querySelector('.reel-video');
                        if (videoElement) {
                            videoObserver.observe(videoElement);
                        }
                    }
                }

                setTimeout(() => {
                    reelsContainer.scrollTo({
                        top: 0,
                        behavior: 'smooth'
                    });

                    if (reelsContainer.children.length > 0) {
                        const firstVideo = reelsContainer.querySelector('.reel-video');
                        const firstMuteButton = reelsContainer.querySelector('.mute-unmute-btn'); // Get the first mute button

                        if (firstVideo) {
                            firstVideo.muted = isMutedGlobally;
                            firstVideo.play().catch(error => {
                                console.warn("Initial autoplay prevented:", error);
                            });
                            currentlyPlayingVideo = firstVideo;

                            // Set initial visibility for the first video's mute button
                            if (firstMuteButton) {
                                if (isMutedGlobally) {
                                    firstMuteButton.classList.remove('hidden');
                                } else {
                                    firstMuteButton.classList.add('hidden');
                                }
                            }
                        }
                    }
                }, 100);

            } catch (error) {
                console.error("Error fetching video tweets:", error);
                reelsContainer.innerHTML = '<p style="text-align: center; color: red; margin: auto; padding-top: 50vh;">Error loading videos. Please try again.</p>';
            }
        }

        // Shuffle array helper
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        // Event listeners for navigation buttons
        forYouBtn.addEventListener('click', () => {
            if (currentView !== 'forYou') {
                currentView = 'forYou';
                forYouBtn.classList.add('active');
                followingBtn.classList.remove('active');
                fetchAndDisplayReels(currentView);
            }
        });

        followingBtn.addEventListener('click', () => {
            if (currentView !== 'following') {
                currentView = 'following';
                forYouBtn.classList.remove('active');
                followingBtn.classList.add('active');
                fetchAndDisplayReels(currentView);
            }
        });


        // Check authentication state on page load
        auth.onAuthStateChanged(async (user) => {
            if (user) {
                currentUserId = user.uid;
                try {
                    const userDoc = await db.collection('users').doc(user.uid).get();
                    if (userDoc.exists && userDoc.data().username) {
                        currentUsername = userDoc.data().username;
                        await fetchFollowingList(currentUserId);
                        // Initial load of reels based on default view
                        fetchAndDisplayReels(currentView);
                    } else {
                        window.location.href = 'index.html';
                    }
                } catch (error) {
                    console.error("Error fetching current user data:", error);
                    window.location.href = 'index.html';
                }
            } else {
                window.location.href = 'index.html';
            }
        });

    </script>
</body>
</html>
